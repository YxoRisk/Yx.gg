--> Services | Variables <--
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

--> LocalPlayer | Variables <--
local player = Players.LocalPlayer
local playerCamera = Workspace.CurrentCamera

--> Targeted Player | Variables <--
local TargetedPlayer = nil
local TargetedPlayerCharacter = nil
local TargetedPlayerAimPart = nil

--> Silent Aim | Global Variables <--
getgenv().YxSilent = {
    Settings = {
        Toggled = true,
        AimPart = "HumanoidRootPart",
        HitChance = math.huge,
       },
    },
}

local Hit_Success = false -- don't touch this.

--> ScreenGui | Variables <--
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = CoreGui
ScreenGui.Name = "ScreenGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = false
ScreenGui.DisplayOrder = 9e9
ScreenGui.Enabled = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.AutoLocalize = true
ScreenGui.Archivable = true

--> FOV Circle | Variables <--
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = true
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Transparency = 1
FOVCircle.Thickness = 1
FOVCircle.NumSides = 1000
FOVCircle.Radius = playerCamera.ViewportSize.X / 8
FOVCircle.Filled = false
FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)

--> Tracer | Variables <--
local function CreateTracer()
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = Color3.fromRGB(160, 32, 240)
    tracer.Thickness = 1
    tracer.From = Vector2.new(0, 0)
    tracer.To = Vector2.new(0, 0)
    return tracer
end

local tracer = CreateTracer()

--> Function To Handle LocalPlayer Respawns <--
player.CharacterAdded:Connect(function(NewCharacter)
    playerCharacter = NewCharacter
end)

--> Function To Get The Closest Player <--
local function GetClosestPlayer()
    local ClosestPlayer = nil
    local ShortestDistance = math.huge

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRootPart = Player.Character.HumanoidRootPart
            local PlayerScreenPosition = playerCamera:WorldToViewportPoint(playerRootPart.Position)
            local Direction = (playerRootPart.Position - playerCamera.CFrame.Position).unit
            local DotProduct = playerCamera.CFrame.LookVector:Dot(Direction)

            if DotProduct > 0 then
                local MagnitudeDistance = (Vector2.new(PlayerScreenPosition.X, PlayerScreenPosition.Y) - FOVCircle.Position).Magnitude

                if MagnitudeDistance < ShortestDistance and MagnitudeDistance <= FOVCircle.Radius then
                    local ray = Ray.new(playerCamera.CFrame.Position, (playerRootPart.Position - playerCamera.CFrame.Position).unit * (playerRootPart.Position - playerCamera.CFrame.Position).magnitude)
                    local hitPart, hitPosition = Workspace:FindPartOnRay(ray, player.Character, false, true)

                    if not hitPart or hitPart:IsDescendantOf(Player.Character) then
                        ClosestPlayer = Player
                        ShortestDistance = MagnitudeDistance
                    end
                end
            end
        end
    end
    return ClosestPlayer
end

--> Function To Get Closest AimPart Based on Screen Center <--
local function GetClosestAimPart(targetPlayer)
    local aimParts = {
        "Head", "UpperTorso", "HumanoidRootPart", "LowerTorso",
        "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm",
        "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg",
        "LeftUpperLeg", "RightLowerLeg", "RightFoot", "RightUpperLeg"
    }

    local screenCenter = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
    local closestPart = nil
    local closestDistance = math.huge

    for _, partName in ipairs(aimParts) do
        local part = targetPlayer.Character:FindFirstChild(partName)
        if part and part:IsA("BasePart") and part.Transparency < 1 then
            local screenPosition = playerCamera:WorldToViewportPoint(part.Position)
            local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude

            if distance < closestDistance then
                closestDistance = distance
                closestPart = part
            end
        end
    end

    return closestPart
end

--> Function To Handle Targeted Player Variables <-- 
RunService.RenderStepped:Connect(function(deltaTime)
    TargetedPlayer = GetClosestPlayer()
    if TargetedPlayer and TargetedPlayer.Character then
        TargetedPlayerCharacter = TargetedPlayer.Character
        TargetedPlayerAimPart = GetClosestAimPart(TargetedPlayer)
        if TargetedPlayerAimPart then
            local aimPartScreenPosition = playerCamera:WorldToViewportPoint(TargetedPlayerAimPart.Position)
            tracer.Visible = true
            tracer.From = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
            tracer.To = Vector2.new(aimPartScreenPosition.X, aimPartScreenPosition.Y)
        else
            tracer.Visible = false
        end
    else
        tracer.Visible = false
    end
end)

--[[
--> Variables
--]]
local lastNotificationTime = 0
local pingvalue = nil
local split = nil
local ping = nil

--[[
--> Generate Prediction Value Function
--]]
local function generatePredictionValue(ping)
    local baseValues = {
        {maxPing = 10, base = 0.15},
        {maxPing = 30, base = 0.115},
        {maxPing = 50, base = 0.125},
        {maxPing = 70, base = 0.135},
        {maxPing = 90, base = 0.145},
        {maxPing = 110, base = 0.155},
        {maxPing = 130, base = 0.165},
        {maxPing = 150, base = 0.175},
        {maxPing = 170, base = 0.185},
        {maxPing = 190, base = 0.195},
        {maxPing = 210, base = 0.205},
        {maxPing = 230, base = 0.215},
        {maxPing = 250, base = 0.225},
        -- Add more if needed
    }

    local predictionGenerator = 0.235
    for _, range in ipairs(baseValues) do
        if ping <= range.maxPing then
            predictionGenerator = range.base
            break
        end
    end

    return predictionGenerator
end

--[[
--> Update Prediction Value Based on Ping
--]]
RunService.Stepped:Connect(function()
    if YxSilent.Settings.Prediction.Toggled then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue, '(')
        local ping = tonumber(split[1])

        YxSilent.Settings.Prediction.Horizontal = generatePredictionValue(ping)
    end
end)

--> RawMetaTable | Variables <--
local mt = getrawmetatable(game)
local old = mt.__namecall

setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if YxSilent.Settings.Toggled and getnamecallmethod() == "FireServer" and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        if args[2] == "UpdateMousePos" then
            if YxSilent.Settings.Prediction.Toggled then
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * YxSilent.Settings.Prediction.Horizontal)}
                else
                    args[3] = TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * YxSilent.Settings.Prediction.Horizontal)
                end
            else
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position}
                else
                    args[3] = TargetedPlayerAimPart.Position
                end
            end
        elseif args[2] == "MOUSE" then
            if YxSilent.Settings.Prediction.Toggled then
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * YxSilent.Settings.Prediction.Horizontal)}
                else
                    args[3] = TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * YxSilent.Settings.Prediction.Horizontal)
                end
            else
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position}
                else
                    args[3] = TargetedPlayerAimPart.Position
                end
            end
        end
    end

    return old(...)
end)

setreadonly(mt, true)

--> GUI Button For Sticky Aim <--
local stickyAimButton = Instance.new("TextButton")
stickyAimButton.Size = UDim2.new(0, 100, 0, 50)
stickyAimButton.Position = UDim2.new(0.5, -50, 0.9, -25)
stickyAimButton.Text = "StickyAim Off"
stickyAimButton.Parent = ScreenGui
stickyAimButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
stickyAimButton.TextColor3 = Color3.fromRGB(255, 255, 255)

local stickyAimEnabled = false

stickyAimButton.MouseButton1Click:Connect(function()
    stickyAimEnabled = not stickyAimEnabled
    if stickyAimEnabled then
        stickyAimButton.Text = "StickyAim On"
    else
        stickyAimButton.Text = "StickyAim Off"
    end
end)

--> Update FOV Circle Position | Sticky Aim <--
RunService.RenderStepped:Connect(function()
    if stickyAimEnabled and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        local screenPosition = playerCamera:WorldToViewportPoint(TargetedPlayerAimPart.Position)
        if screenPosition.Z > 0 then
            FOVCircle.Position = Vector2.new(screenPosition.X, screenPosition.Y)
        else
            FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
        end
    else
        FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
    end
end)

--[[
--> Function To Toggle Only Target Lock
--]]
local onlyTargetEnabled = false
local function ToggleOnlyTargetLock()
    onlyTargetEnabled = not onlyTargetEnabled
    if onlyTargetEnabled then
        local notificationText = "OnlyTarget Lock: " .. (TargetedPlayer and TargetedPlayer.DisplayName or "No Target")
        game.StarterGui:SetCore("SendNotification", {
            Title = "YxSilent Notification",
            Text = notificationText,
            Duration = 5
        })
    end
end

--[[
--> Bind Key To Toggle Only Target Lock
--]]
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.T then -- Change 'T' to whatever key you want
        ToggleOnlyTargetLock()
    end
end)

--[[
--> Sticky Aim
--]]
RunService.RenderStepped:Connect(function()
    if stickyAimEnabled and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        local screenPosition = playerCamera:WorldToViewportPoint(TargetedPlayerAimPart.Position)
        if screenPosition.Z > 0 then
            FOVCircle.Position = Vector2.new(screenPosition.X, screenPosition.Y)
        else
            FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
        end
    else
        FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
    end
end)
