--> Services | Variables <--
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

--> LocalPlayer | Variables <--
local player = Players.LocalPlayer
local playerCamera = Workspace.CurrentCamera

--> Targeted Player | Variables <--
local TargetedPlayer = nil
local TargetedPlayerCharacter = nil
local TargetedPlayerAimPart = nil

--> Silent Aim | Global Variables <--
getgenv().Silent = {
    Settings = {
        Toggled = true,
        AimPart = "HumanoidRootPart",
        HitChance = math.huge,
        Prediction = {
            Toggled = true,
            Horizontal = 0.16,
            Vertical = 0.06,
        },
        Circle = {
            Visible = true,
            Color = Color3.fromRGB(255, 255, 255),
            Transparency = 1,
            Thickness = 1,
            NumSides = 1000,
            Radius = 8,
            Filled = false,
        },
    },
}

local Hit_Success = false -- don't touch this.

--> ScreenGui | Variables <--
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = CoreGui
ScreenGui.Name = "ScreenGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = false
ScreenGui.DisplayOrder = 9e9
ScreenGui.Enabled = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.AutoLocalize = true
ScreenGui.Archivable = true

--> FOV Circle | Variables <--
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = Silent.Settings.Circle.Visible
FOVCircle.Color = Silent.Settings.Circle.Color
FOVCircle.Transparency = Silent.Settings.Circle.Transparency
FOVCircle.Thickness = Silent.Settings.Circle.Thickness
FOVCircle.NumSides = Silent.Settings.Circle.NumSides
FOVCircle.Radius = playerCamera.ViewportSize.X / Silent.Settings.Circle.Radius
FOVCircle.Filled = Silent.Settings.Circle.Filled
FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)

--> Tracer | Variables <--
local function CreateTracer()
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = Color3.fromRGB(160, 32, 240)
    tracer.Thickness = 1
    tracer.From = Vector2.new(0, 0)
    tracer.To = Vector2.new(0, 0)
    return tracer
end

local tracer = CreateTracer()

--> Function To Handle LocalPlayer Respawns <--
player.CharacterAdded:Connect(function(NewCharacter)
    playerCharacter = NewCharacter
end)

--> Function To Get The Closest Player <--
local function GetClosestPlayer()
    local ClosestPlayer = nil
    local ShortestDistance = math.huge

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRootPart = Player.Character.HumanoidRootPart
            local PlayerScreenPosition = playerCamera:WorldToViewportPoint(playerRootPart.Position)
            local Direction = (playerRootPart.Position - playerCamera.CFrame.Position).unit
            local DotProduct = playerCamera.CFrame.LookVector:Dot(Direction)

            if DotProduct > 0 then
                local MagnitudeDistance = (Vector2.new(PlayerScreenPosition.X, PlayerScreenPosition.Y) - FOVCircle.Position).Magnitude

                if MagnitudeDistance < ShortestDistance and MagnitudeDistance <= FOVCircle.Radius then
                    local ray = Ray.new(playerCamera.CFrame.Position, (playerRootPart.Position - playerCamera.CFrame.Position).unit * (playerRootPart.Position - playerCamera.CFrame.Position).magnitude)
                    local hitPart, hitPosition = Workspace:FindPartOnRay(ray, player.Character, false, true)

                    if not hitPart or hitPart:IsDescendantOf(Player.Character) then
                        ClosestPlayer = Player
                        ShortestDistance = MagnitudeDistance
                    end
                end
            end
        end
    end
    return ClosestPlayer
end

--> Function To Get Closest AimPart Based on Screen Center <--
local function GetClosestAimPart(targetPlayer)
    local aimParts = {
        "Head", "UpperTorso", "HumanoidRootPart", "LowerTorso",
        "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm",
        "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg",
        "LeftUpperLeg", "RightLowerLeg", "RightFoot", "RightUpperLeg"
    }

    local screenCenter = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
    local closestPart = nil
    local closestDistance = math.huge

    for _, partName in ipairs(aimParts) do
        local part = targetPlayer.Character:FindFirstChild(partName)
        if part and part:IsA("BasePart") and part.Transparency < 1 then
            local screenPosition = playerCamera:WorldToViewportPoint(part.Position)
            local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude

            if distance < closestDistance then
                closestDistance = distance
                closestPart = part
            end
        end
    end

    return closestPart
end

--> Function To Handle Targeted Player Variables <-- 
RunService.RenderStepped:Connect(function(deltaTime)
    TargetedPlayer = GetClosestPlayer()
    if TargetedPlayer and TargetedPlayer.Character then
        TargetedPlayerCharacter = TargetedPlayer.Character
        TargetedPlayerAimPart = GetClosestAimPart(TargetedPlayer)
        if TargetedPlayerAimPart then
            local aimPartScreenPosition = playerCamera:WorldToViewportPoint(TargetedPlayerAimPart.Position)
            tracer.Visible = true
            tracer.From = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
            tracer.To = Vector2.new(aimPartScreenPosition.X, aimPartScreenPosition.Y)
        else
            tracer.Visible = false
        end
    else
        tracer.Visible = false
    end
end)

--[[
--> Variables
--]]
local lastNotificationTime = 0
local pingvalue = nil
local split = nil
local ping = nil

--[[
--> Generate Prediction Value Function
--]]
local function generatePredictionValue(ping)
    local baseValues = {
        {maxPing = 10, base = 0.05},
        {maxPing = 30, base = 0.015},
        {maxPing = 50, base = 0.025},
        {maxPing = 70, base = 0.035},
        {maxPing = 90, base = 0.045},
        {maxPing = 110, base = 0.055},
        {maxPing = 130, base = 0.065},
        {maxPing = 150, base = 0.075},
        {maxPing = 170, base = 0.085},
        {maxPing = 190, base = 0.095},
        {maxPing = 210, base = 0.005},
        {maxPing = 230, base = 0.015},
        {maxPing = 250, base = 0.025},
        -- Add more if needed
    }

    for _, range in ipairs(baseValues) do
        if ping <= range.maxPing then
            horizontalValue = range.base
            break
        end
    end

    return horizontalValue
end

--[[
--> Update Prediction Value Based on Ping
--]]
RunService.Stepped:Connect(function()
    if Silent.Settings.Prediction.Toggled then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue, '(')
        local ping = tonumber(split[1])

        horizontalValue = generatePredictionValue(ping)
    end
end)

--> RawMetaTable | Variables <--
local mt = getrawmetatable(game)
local old = mt.__namecall

setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if Silent.Settings.Toggled and getnamecallmethod() == "FireServer" and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        if args[2] == "UpdateMousePos" then
            if Silent.Settings.Prediction.Toggled then
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * Silent.Settings.Prediction.Horizontal)}
                else
                    args[3] = TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * Silent.Settings.Prediction.Horizontal)
                end
            else
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position}
                else
                    args[3] = TargetedPlayerAimPart.Position
end
            end
        elseif args[2] == "MOUSE" then
            if Silent.Settings.Prediction.Toggled then
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * Silent.Settings.Prediction.Horizontal)}
                else
                    args[3] = TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * Silent.Settings.Prediction.Horizontal)
                end
            else
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position}
                else
                    args[3] = TargetedPlayerAimPart.Position
                end
            end
        elseif args[2] == "MousePos" then
            if Silent.Settings.Prediction.Toggled then
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * Silent.Settings.Prediction.Horizontal)}
                else
                    args[3] = TargetedPlayerAimPart.Position + (TargetedPlayerAimPart.Velocity * Silent.Settings.Prediction.Horizontal)
                end
            else
                if type(args[3]) == "table" then
                    args[3] = {TargetedPlayerAimPart.Position}
                else
                    args[3] = TargetedPlayerAimPart.Position
                end
            end
        end
        return old(unpack(args))
    end
    return old(...)
end)

--[[
--> Variables
--]]
local SilentAimState = Silent.Settings.Toggled

--[[
--> GUI untuk Mengaktifkan dan Menonaktifkan Silent Aim
--]]
local SilentAimGui = Instance.new("ScreenGui")
SilentAimGui.Name = "SilentAimGui"
SilentAimGui.Parent = CoreGui
SilentAimGui.ResetOnSpawn = false
SilentAimGui.IgnoreGuiInset = false
SilentAimGui.DisplayOrder = 9e9
SilentAimGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
SilentAimGui.AutoLocalize = true
SilentAimGui.Archivable = true

local SilentAimFrame = Instance.new("Frame")
SilentAimFrame.Parent = SilentAimGui
SilentAimFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
SilentAimFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
SilentAimFrame.BorderSizePixel = 0
SilentAimFrame.Position = UDim2.new(0.1, 0, 0.2, 0)
SilentAimFrame.Size = UDim2.new(0, 150, 0, 50)
SilentAimFrame.Active = true
SilentAimFrame.Draggable = true

local UICorner = Instance.new("UICorner")
UICorner.Parent = SilentAimFrame

local SilentAimButton = Instance.new("TextButton")
SilentAimButton.Parent = SilentAimFrame
SilentAimButton.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
SilentAimButton.BackgroundTransparency = 5
SilentAimButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
SilentAimButton.BorderSizePixel = 0
SilentAimButton.Position = UDim2.new(0.1, 0, 0.2, 0)
SilentAimButton.Size = UDim2.new(0, 120, 0, 30)
SilentAimButton.Font = Enum.Font.SourceSansSemibold
SilentAimButton.Text = SilentAimState and "Silent Aim On" or "Silent Aim Off"
SilentAimButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SilentAimButton.TextScaled = true
SilentAimButton.TextSize = 18
SilentAimButton.TextWrapped = true

SilentAimButton.MouseButton1Click:Connect(function()
    SilentAimState = not SilentAimState
    SilentAimButton.Text = SilentAimState and "Silent Aim On" or "Silent Aim Off"
    Silent.Settings.Toggled = SilentAimState
end)

--[[
--> Sticky Aim Function
--]]
local StickyAimState = false
local enemy = nil

local StickyAimGui = Instance.new("ScreenGui")
StickyAimGui.Name = "StickyAimGui"
StickyAimGui.Parent = CoreGui
StickyAimGui.ResetOnSpawn = false
StickyAimGui.IgnoreGuiInset = false
StickyAimGui.DisplayOrder = 9e9
StickyAimGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
StickyAimGui.AutoLocalize = true
StickyAimGui.Archivable = true

local StickyAimFrame = Instance.new("Frame")
StickyAimFrame.Parent = StickyAimGui
StickyAimFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
StickyAimFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
StickyAimFrame.BorderSizePixel = 0
StickyAimFrame.Position = UDim2.new(0.1, 0, 0.3, 0)
StickyAimFrame.Size = UDim2.new(0, 150, 0, 50)
StickyAimFrame.Active = true
StickyAimFrame.Draggable = true

local UICorner = Instance.new("UICorner")
UICorner.Parent = StickyAimFrame

local StickyAimButton = Instance.new("TextButton")
StickyAimButton.Parent = StickyAimFrame
StickyAimButton.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
StickyAimButton.BackgroundTransparency = 5
StickyAimButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
StickyAimButton.BorderSizePixel = 0
StickyAimButton.Position = UDim2.new(0.1, 0, 0.2, 0)
StickyAimButton.Size = UDim2.new(0, 120, 0, 30)
StickyAimButton.Font = Enum.Font.SourceSansSemibold
StickyAimButton.Text = "StickyAim Off"
StickyAimButton.TextColor3 = Color3.fromRGB(255, 255, 255)
StickyAimButton.TextScaled = true
StickyAimButton.TextSize = 18
StickyAimButton.TextWrapped = true

StickyAimButton.MouseButton1Click:Connect(function()
    StickyAimState = not StickyAimState
    StickyAimButton.Text = StickyAimState and "StickyAim On" or "StickyAim Off"
    if StickyAimState then
        enemy = GetClosestPlayer()
    else
        enemy = nil
    end
end)

--[[
--> Sticky Aim Function
--]]
RunService.RenderStepped:Connect(function()
    if StickyAimState and enemy then
        local targetPart = GetClosestAimPart(enemy)
        if targetPart then
            local targetPosition = playerCamera:WorldToViewportPoint(targetPart.Position)
            FOVCircle.Position = Vector2.new(targetPosition.X, targetPosition.Y)
        else
            FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
        end
    else
        FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
    end
end)

--> GUI untuk Prediction
local PredictionGui = Instance.new("ScreenGui")
PredictionGui.Name = "PredictionGui"
PredictionGui.Parent = CoreGui
PredictionGui.ResetOnSpawn = false
PredictionGui.IgnoreGuiInset = false
PredictionGui.DisplayOrder = 9e9
PredictionGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
PredictionGui.AutoLocalize = true
PredictionGui.Archivable = true

local PredictionFrame = Instance.new("Frame")
PredictionFrame.Parent = PredictionGui
PredictionFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
PredictionFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
PredictionFrame.BorderSizePixel = 0
PredictionFrame.Position = UDim2.new(0.1, 0, 0.4, 0)
PredictionFrame.Size = UDim2.new(0, 200, 0.1, 100)
PredictionFrame.Active = true
PredictionFrame.Draggable = true

local UICorner = Instance.new("UICorner")
UICorner.Parent = PredictionFrame

local HorizontalTextBox = Instance.new("TextBox")
HorizontalTextBox.Parent = PredictionFrame
HorizontalTextBox.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
HorizontalTextBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
HorizontalTextBox.BorderSizePixel = 0
HorizontalTextBox.Position = UDim2.new(0.05, 0, 0.2, 0)
HorizontalTextBox.Size = UDim2.new(0, 80, 0, 30)
HorizontalTextBox.Font = Enum.Font.SourceSans
HorizontalTextBox.Text = tostring(Silent.Settings.Prediction.Horizontal)
HorizontalTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
HorizontalTextBox.TextScaled = true
HorizontalTextBox.TextSize = 18
HorizontalTextBox.TextWrapped = true
HorizontalTextBox.PlaceholderText = "Horizontal"

local VerticalTextBox = Instance.new("TextBox")
VerticalTextBox.Parent = PredictionFrame
VerticalTextBox.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
VerticalTextBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
VerticalTextBox.BorderSizePixel = 0
VerticalTextBox.Position = UDim2.new(0.55, 0, 0.2, 0)
VerticalTextBox.Size = UDim2.new(0, 80, 0, 30)
VerticalTextBox.Font = Enum.Font.SourceSans
VerticalTextBox.Text = tostring(Silent.Settings.Prediction.Vertical)
VerticalTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
VerticalTextBox.TextScaled = true
VerticalTextBox.TextSize = 18
VerticalTextBox.TextWrapped = true
VerticalTextBox.PlaceholderText = "Vertical"

local ApplyButton = Instance.new("TextButton")
ApplyButton.Parent = PredictionFrame
ApplyButton.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
ApplyButton.BackgroundTransparency = 5
ApplyButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
ApplyButton.BorderSizePixel = 0
ApplyButton.Position = UDim2.new(0.5, -60, 0.6, 0)
ApplyButton.Size = UDim2.new(0, 120, 0, 30)
ApplyButton.Font = Enum.Font.SourceSansSemibold
ApplyButton.Text = "Apply"
ApplyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ApplyButton.TextScaled = true
ApplyButton.TextSize = 18
ApplyButton.TextWrapped = true

local Title = Instance.new("TextLabel")
    Title.Parent = PredictionFrame
Title.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
Title.BackgroundTransparency = 5
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0.5, -60, 0, 0)
Title.Size = UDim2.new(0, 120, 0, 20)
Title.Font = Enum.Font.SourceSansSemibold
Title.Text = "Prediction"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.TextSize = 15
Title.TextWrapped = true


local function sendnotif(title, text)
    local Notification = Instance.new("Frame")
    Notification.Parent = ScreenGui
    Notification.Size = UDim2.new(0, 200, 0, 100)
    Notification.Position = UDim2.new(0.5, -100, 0.5, -50)
    Notification.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Notification.BorderSizePixel = 0

    local Title = Instance.new("TextLabel")
    Title.Parent = Notification
    Title.Size = UDim2.new(1, 0, 0, 30)
    Title.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Text = title
    Title.TextSize = 16

    local Text = Instance.new("TextLabel")
    Text.Parent = Notification
    Text.Size = UDim2.new(1, 0, 0, 70)
    Text.Position = UDim2.new(0, 0, 0, 30)
    Text.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Text.TextColor3 = Color3.fromRGB(255, 255, 255)
    Text.Text = text
    Text.TextSize = 16
    Text.TextWrapped = true

    wait(3)
    Notification:Destroy()
end

ApplyButton.MouseButton1Click:Connect(function()
    local horizontalValue = tonumber(HorizontalTextBox.Text)
    local verticalValue = tonumber(VerticalTextBox.Text)
    
    if horizontalValue and verticalValue then
        sendnotif("Applying Prediction", "Horizontal: " .. tostring(horizontalValue) .. ", Vertical: " .. tostring(verticalValue))
        Silent.Settings.Prediction.Horizontal = horizontalValue
        Silent.Settings.Prediction.Vertical = verticalValue
    else
        sendnotif("Error", "Invalid input for Prediction values.")
    end
end)


-- Function to send a custom notification
local function SendCustomNotification(title, description)
    local Notification = Instance.new("ScreenGui")
    local Frame = Instance.new("Frame")
    local UICorner = Instance.new("UICorner")
    local TitleLabel = Instance.new("TextLabel")
    local DescriptionLabel = Instance.new("TextLabel")

    -- Properties
    Notification.Name = "NotificationGui"
    Notification.Parent = game.CoreGui
    Notification.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    Frame.Parent = Notification
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BorderSizePixel = 0
    Frame.Position = UDim2.new(0.5, -100, 0.8, -30)
    Frame.Size = UDim2.new(0, 300, 0, 60)
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.BackgroundTransparency = 0.5

    UICorner.Parent = Frame

    TitleLabel.Parent = Frame
    TitleLabel.BackgroundTransparency = 1
    TitleLabel.Position = UDim2.new(0, 0, 0, 0)
    TitleLabel.Size = UDim2.new(1, 0, 0.5, 0)
    TitleLabel.Font = Enum.Font.SourceSansBold
    TitleLabel.Text = title
    TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TitleLabel.TextSize = 18
    TitleLabel.TextWrapped = true
    TitleLabel.TextStrokeTransparency = 0.5

    DescriptionLabel.Parent = Frame
    DescriptionLabel.BackgroundTransparency = 1
    DescriptionLabel.Position = UDim2.new(0, 0, 0.5, 0)
    DescriptionLabel.Size = UDim2.new(1, 0, 0.5, 0)
    DescriptionLabel.Font = Enum.Font.SourceSans
    DescriptionLabel.Text = description
    DescriptionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    DescriptionLabel.TextSize = 14
    DescriptionLabel.TextWrapped = true
    DescriptionLabel.TextStrokeTransparency = 0.5

    -- Animation
    Frame.Position = UDim2.new(0.7, -150, 1, 0)
    Frame:TweenPosition(UDim2.new(0.728, -145, 0.5, -30), "Out", "Quad", 0.728, true)
    wait(8)
    Frame:TweenPosition(UDim2.new(0.728, -150, 1, 0), "In", "Quad", 0.728, true)
    wait(0.5)
    Notification:Destroy()
end

SendCustomNotification("Yx.GGs", "YxSilent")





game.StarterGui:SetCore("SendNotification", {
    Title = "Yx.GGs";
    Text = "for update: https://discord.com/invite/cMzPqDGwRV";
    Duration = 8;
})
